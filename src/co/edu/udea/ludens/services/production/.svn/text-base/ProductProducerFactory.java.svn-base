package co.edu.udea.ludens.services.production;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.apache.log4j.Logger;

import co.edu.udea.ludens.domain.Element;
import co.edu.udea.ludens.domain.Incrementable;
import co.edu.udea.ludens.domain.LevelConstraint;
import co.edu.udea.ludens.domain.Player;
import co.edu.udea.ludens.domain.Population;
import co.edu.udea.ludens.enums.EnumElementType;
import co.edu.udea.ludens.enums.EnumMsgs;
import co.edu.udea.ludens.exceptions.LudensException;
import co.edu.udea.ludens.services.ElementProcess;
import co.edu.udea.ludens.util.ProducerUtil;
import co.edu.udea.ludens.web.ElementBean;

public class ProductProducerFactory {

	private static Logger logger = Logger.getLogger(ProductProducerFactory.class);
	
	public int UPGRADING_LIVEL_DURATION = 30;// seconds

	public static List<ElementBean> initBeans(	HashMap<String, Element> elements, ElementProcess process) {

		List<ElementBean> elementBeans = new ArrayList<ElementBean>();

		for (Object key : elements.keySet()) {

			Incrementable incre = null;
			Integer production = 0;
			incre = elements.get(key);
			ElementBean bean = new ElementBean();
			bean.setIncrementable(incre);
			bean.setProduction(production);
			bean.setProcess(process);
			elementBeans.add(bean);

		}

		return elementBeans;

	}

	public static List<ElementBean> initPopulation(Population population,ElementProcess process) {

		List<ElementBean> elementBeans = new ArrayList<ElementBean>();

		Incrementable incre = null;
		Integer production = 0;
		incre = population;
		ElementBean bean = new ElementBean();
		bean.setIncrementable(incre);
		bean.setProduction(production);
		bean.setProcess(process);
		elementBeans.add(bean);

		return elementBeans;

	}

	public static void upLevel(Element element, Player player) throws LudensException {

        boolean error = false;	

		Integer actualLevel = element.getLevel();	
		Integer newLevel = actualLevel + 1;	

		List<LevelConstraint> ctrs = element.getLevelConstraints().get(newLevel + "");		
		// if didn't find resources constraints for this level then throw an exception
		if (ctrs == null) {	
			throw new LudensException(EnumMsgs.CANT_UP_LEVEL,element.getName(), newLevel);
		}
		
		//  we check out resources in order to know if we have enough to up the level
		ProducerUtil.checkOutResources(ctrs, element,player);
		//Here, we have decremented each resource consumed to up to the next level
		for (LevelConstraint pk : ctrs) {

			Integer neededQuantity = pk.getQuantity();
			String resourceName = pk.getElementName();
			Element resource = player.getCommunity().getMaterials().get(resourceName);
			Integer quantity = resource.getQuantity() - neededQuantity;
			resource.setQuantity(quantity);
		}		
	  
		// start to track  time in order to calculate population increase
	     ProducerUtil.addStartTimePlayer(player);
	   
	
	   
	  
  	   	    
	   try {   
		   
		   
		   logger.info("Esperando "+element.getActualUpgradingTime()+" segundos para subir nivel");;
		   player.setProducing(true);
		   Thread.sleep(element.getActualUpgradingTime()*1000);
		   logger.info("Listo subir nivel de "+element.getName());
		
	} catch (InterruptedException e) {
		logger.info("Error esperando para subir nivel", e);
		error = true;
	}
	   

	
	 	 
	   
       if(!error){
	   element.setLevel(newLevel);
	   ProducerUtil.updateUpgradingDelay(element);
	   player.setProducing(false);
       }
	   
	  
	   

	}



	public static ProducerStrategy createProducer(EnumElementType productType) {

		if (EnumElementType.FACTOR == productType) {
			return new FactorProducerWithGrowthRate();
		}

		if (EnumElementType.MATERIAL == productType) {
			return new MaterialProducerWithGrowthRate();
		}

		if (EnumElementType.POPULATION == productType) {
			return new PopulationProducerWithGrowthRate();
		}

		return null;
	}
	
	
	public  static Double calculateExpGrowth(int p0, double lambda,	int n) {
		
		logger.info("Calculating exp ..");

		double lambdaD = lambda / 100;

		logger.info("LambdaD .." + lambdaD);

		Double result = p0 * Math.exp(lambdaD * n);
		
		logger.info("result .." + result);

		return result;
	}

}
